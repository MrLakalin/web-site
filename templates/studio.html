{% extends "base.html" %}

{% block title %}Студия{% endblock %}

{% block content %}
<section class="studio-layout">
    <div class="canvas-wrapper">
        <canvas id="drawingCanvas" width="900" height="600"></canvas>
    </div>
    <aside class="toolbox">
        <h3>Инструменты</h3>
        <div class="tool-selector" role="toolbar" aria-label="Набор инструментов">
            <button type="button" class="tool-btn active" data-tool="brush" aria-label="Кисть">
                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M3 21s2-1 3-5c1-3 4-5 4-5s2-3 5-4c3-1 6-3 6-3l-6 6s-1 4-4 5c-3 1-8 6-8 6z" stroke-linecap="round" stroke-linejoin="round"/></svg>
            </button>
            <button type="button" class="tool-btn" data-tool="marker" aria-label="Маркер">
                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M3 17l7.5-7.5 4.5 4.5L7.5 21H3z"/><path d="M14.5 5.5l4 4" stroke-linecap="round"/></svg>
            </button>
            <button type="button" class="tool-btn" data-tool="line" aria-label="Линия">
                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M4 20L20 4" stroke-linecap="round"/></svg>
            </button>
            <button type="button" class="tool-btn" data-tool="rectangle" aria-label="Прямоугольник">
                <svg viewBox="0 0 24 24" aria-hidden="true"><rect x="5" y="5" width="14" height="14" rx="2"/></svg>
            </button>
            <button type="button" class="tool-btn" data-tool="circle" aria-label="Круг">
                <svg viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="7"/></svg>
            </button>
            <button type="button" class="tool-btn" data-tool="star" aria-label="Звезда">
                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 4l2.2 4.8 5.3.6-3.9 3.6 1.1 5.2L12 15.8 7.3 18.2 8.4 13 4.5 9.4 9.8 8.8z"/></svg>
            </button>
            <button type="button" class="tool-btn" data-tool="fill" aria-label="Заливка">
                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M6 2l9 9-4 4-9-9z"/><path d="M16 12c0 1.5 2 4 2 4s2-2.5 2-4a2 2 0 0 0-4 0z"/></svg>
            </button>
            <button type="button" class="tool-btn" data-tool="eraser" aria-label="Ластик">
                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M16 3l5 5-11 11H5L3 17z"/><path d="M9 21h12"/></svg>
            </button>
        </div>

        <label>Название рисунка
            <input id="drawingTitle" placeholder="Без названия" value="{{ drawing.title if drawing else '' }}">
        </label>

        <label>Цвет кисти
            <input type="color" id="colorPicker" value="#1e1e1e">
        </label>

        <label>Толщина кисти
            <input type="range" id="brushSize" min="1" max="40" value="5">
            <span id="brushSizeValue">5px</span>
        </label>

        <div class="tool-buttons">
            <button id="clearBtn" class="btn btn-secondary" type="button">Очистить</button>
        </div>
        <div class="tool-buttons">
            <button id="saveBtn" class="btn btn-primary" type="button">Сохранить</button>
        </div>
    </aside>
</section>
{% endblock %}

{% block scripts %}
<script>
window.drawingContext = {{ {
    "id": drawing.id if drawing else None,
    "title": drawing.title if drawing else "",
    "imageData": drawing.image_data if drawing else "",
}|tojson|safe }};

(() => {
    const canvas = document.getElementById("drawingCanvas");
    const ctx = canvas.getContext("2d");
    const colorPicker = document.getElementById("colorPicker");
    const brushSize = document.getElementById("brushSize");
    const brushSizeValue = document.getElementById("brushSizeValue");
    const clearBtn = document.getElementById("clearBtn");
    const saveBtn = document.getElementById("saveBtn");
    const drawingTitle = document.getElementById("drawingTitle");
    const toolButtons = document.querySelectorAll(".tool-btn");

    let isDrawing = false;
    let lastPoint = null;
    let startPoint = null;
    let snapshot = null;
    let currentTool = "brush";
    let hasMoved = false;

    const shapeTools = ["line", "rectangle", "circle", "star"];
    const isShapeTool = (tool) => shapeTools.includes(tool);

    const setTool = (tool) => {
        currentTool = tool;
        toolButtons.forEach((button) => {
            button.classList.toggle("active", button.dataset.tool === tool);
        });
    };

    toolButtons.forEach((button) => {
        button.addEventListener("click", () => setTool(button.dataset.tool));
    });

    const getCoords = (event) => {
        const rect = canvas.getBoundingClientRect();
        const pointer = event.touches ? event.touches[0] : event;
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return {
            x: (pointer.clientX - rect.left) * scaleX,
            y: (pointer.clientY - rect.top) * scaleY,
        };
    };

    const applyStrokeSettings = () => {
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.lineWidth = brushSize.value;
        ctx.globalAlpha = currentTool === "marker" ? 0.35 : 1;
        if (currentTool === "eraser") {
            ctx.strokeStyle = "#ffffff";
            ctx.lineWidth = brushSize.value * 1.3;
        } else {
            ctx.strokeStyle = colorPicker.value;
        }
    };

    const floodFill = (x, y, fillColor) => {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const width = canvas.width;
        const height = canvas.height;
        
        const px = Math.floor(x);
        const py = Math.floor(y);
        
        if (px < 0 || px >= width || py < 0 || py >= height) {
            return;
        }
        
        const startIdx = (py * width + px) * 4;
        
        const targetColor = {
            r: data[startIdx],
            g: data[startIdx + 1],
            b: data[startIdx + 2],
            a: data[startIdx + 3]
        };
        
        const fillR = parseInt(fillColor.slice(1, 3), 16);
        const fillG = parseInt(fillColor.slice(3, 5), 16);
        const fillB = parseInt(fillColor.slice(5, 7), 16);
        
        if (targetColor.r === fillR && targetColor.g === fillG && targetColor.b === fillB) {
            return;
        }
        
        const tolerance = 30;
        const colorDistance = (r1, g1, b1, r2, g2, b2) => {
            return Math.sqrt(
                Math.pow(r1 - r2, 2) + 
                Math.pow(g1 - g2, 2) + 
                Math.pow(b1 - b2, 2)
            );
        };
        
        const isSimilarColor = (r, g, b) => {
            const distance = colorDistance(r, g, b, targetColor.r, targetColor.g, targetColor.b);
            return distance <= tolerance;
        };
        
        const stack = [[px, py]];
        const visited = new Set();
        const filledPixels = [];
        
        while (stack.length > 0) {
            const [cx, cy] = stack.pop();
            const key = `${cx},${cy}`;
            
            if (cx < 0 || cx >= width || cy < 0 || cy >= height || visited.has(key)) {
                continue;
            }
            
            const idx = (cy * width + cx) * 4;
            const r = data[idx];
            const g = data[idx + 1];
            const b = data[idx + 2];
            
            if (isSimilarColor(r, g, b)) {
                data[idx] = fillR;
                data[idx + 1] = fillG;
                data[idx + 2] = fillB;
                data[idx + 3] = 255;
                
                visited.add(key);
                filledPixels.push([cx, cy]);
                
                stack.push([cx + 1, cy]);
                stack.push([cx - 1, cy]);
                stack.push([cx, cy + 1]);
                stack.push([cx, cy - 1]);
            }
        }

        const blendPixel = (nx, ny) => {
            if (nx < 0 || nx >= width || ny < 0 || ny >= height) return;
            const nIdx = (ny * width + nx) * 4;
            data[nIdx] = Math.round(data[nIdx] * 0.5 + fillR * 0.5);
            data[nIdx + 1] = Math.round(data[nIdx + 1] * 0.5 + fillG * 0.5);
            data[nIdx + 2] = Math.round(data[nIdx + 2] * 0.5 + fillB * 0.5);
            data[nIdx + 3] = 255;
        };

        filledPixels.forEach(([fx, fy]) => {
            blendPixel(fx + 1, fy);
            blendPixel(fx - 1, fy);
            blendPixel(fx, fy + 1);
            blendPixel(fx, fy - 1);
            blendPixel(fx + 1, fy + 1);
            blendPixel(fx - 1, fy - 1);
            blendPixel(fx + 1, fy - 1);
            blendPixel(fx - 1, fy + 1);
        });
        
        ctx.putImageData(imageData, 0, 0);
    };

    const startDraw = (event) => {
        event.preventDefault();
        const coords = getCoords(event);
        
        if (currentTool === "fill") {
            floodFill(coords.x, coords.y, colorPicker.value);
            return;
        }
        
        isDrawing = true;
        hasMoved = false;
        lastPoint = coords;
        startPoint = lastPoint;
        if (isShapeTool(currentTool)) {
            snapshot = ctx.getImageData(0, 0, canvas.width, canvas.height);
        } else {
            ctx.globalCompositeOperation = currentTool === "eraser" ? "destination-out" : "source-over";
            drawPoint(coords);
        }
        ctx.globalCompositeOperation = currentTool === "eraser" ? "destination-out" : "source-over";
    };

    const drawPoint = (point) => {
        ctx.globalCompositeOperation = currentTool === "eraser" ? "destination-out" : "source-over";
        ctx.globalAlpha = currentTool === "marker" ? 0.35 : 1;
        if (currentTool === "eraser") {
            ctx.fillStyle = "#ffffff";
        } else {
            ctx.fillStyle = colorPicker.value;
        }
        ctx.beginPath();
        ctx.arc(point.x, point.y, brushSize.value / 2, 0, Math.PI * 2);
        ctx.fill();
    };

    const drawFreehand = (current) => {
        applyStrokeSettings();
        ctx.beginPath();
        ctx.moveTo(lastPoint.x, lastPoint.y);
        ctx.lineTo(current.x, current.y);
        ctx.stroke();
        lastPoint = current;
    };

    const drawShapePreview = (current) => {
        if (!snapshot) return;
        ctx.putImageData(snapshot, 0, 0);
        ctx.globalCompositeOperation = "source-over";
        applyStrokeSettings();
        const width = current.x - startPoint.x;
        const height = current.y - startPoint.y;

        if (currentTool === "line") {
            ctx.beginPath();
            ctx.moveTo(startPoint.x, startPoint.y);
            ctx.lineTo(current.x, current.y);
            ctx.stroke();
        } else if (currentTool === "rectangle") {
            ctx.strokeRect(startPoint.x, startPoint.y, width, height);
        } else if (currentTool === "circle") {
            const radius = Math.sqrt(width ** 2 + height ** 2);
            ctx.beginPath();
            ctx.arc(startPoint.x, startPoint.y, radius, 0, Math.PI * 2);
            ctx.stroke();
        } else if (currentTool === "star") {
            const outerRadius = Math.sqrt(width ** 2 + height ** 2);
            const innerRadius = outerRadius / 2.3;
            ctx.beginPath();
            const points = 5;
            for (let i = 0; i < points * 2; i++) {
                const angle = (Math.PI / points) * i - Math.PI / 2;
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const x = startPoint.x + Math.cos(angle) * radius;
                const y = startPoint.y + Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.stroke();
        }
    };

    const draw = (event) => {
        if (!isDrawing) return;
        event.preventDefault();
        const current = getCoords(event);
        hasMoved = true;
        if (isShapeTool(currentTool)) {
            drawShapePreview(current);
        } else {
            drawFreehand(current);
        }
    };

    const stopDraw = () => {
        if (isShapeTool(currentTool) && snapshot) {
            snapshot = null;
        }
        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = "source-over";
        isDrawing = false;
        hasMoved = false;
    };

    const clearCanvas = () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    };


    const saveDrawing = async () => {
        const title = drawingTitle.value.trim() || "Без названия";
        const imageData = canvas.toDataURL("image/png");
        const isEditMode = Boolean(window.drawingContext?.id);
        const endpoint = isEditMode ? `/api/drawings/${window.drawingContext.id}` : "/api/save_drawing";
        const method = isEditMode ? "PUT" : "POST";
        saveBtn.disabled = true;
        try {
            const response = await fetch(endpoint, {
                method,
                headers: {"Content-Type": "application/json"},
                body: JSON.stringify({ title, imageData }),
            });
            if (!response.ok) throw new Error("Ошибка сохранения");
            drawingTitle.value = "";
            alert("Рисунок сохранён!");
        } catch (error) {
            console.error(error);
            alert("Не удалось сохранить рисунок.");
        } finally {
            saveBtn.disabled = false;
        }
    };

    brushSize.addEventListener("input", (event) => {
        brushSizeValue.textContent = `${event.target.value}px`;
    });

    const fillFromContext = () => {
        if (!window.drawingContext?.imageData) return;
        const image = new Image();
        image.onload = () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
        };
        image.src = window.drawingContext.imageData;
    };

    canvas.addEventListener("mousedown", startDraw);
    canvas.addEventListener("mousemove", draw);
    canvas.addEventListener("mouseup", stopDraw);
    canvas.addEventListener("mouseleave", stopDraw);

    canvas.addEventListener("touchstart", startDraw, { passive: false });
    canvas.addEventListener("touchmove", draw, { passive: false });
    canvas.addEventListener("touchend", stopDraw, { passive: false });

    clearBtn.addEventListener("click", clearCanvas);
    saveBtn.addEventListener("click", saveDrawing);
    fillFromContext();
})();
</script>
{% endblock %}

